#!/usr/bin/env python3
"""
/refactor-function - Automated function complexity reduction

Production implementation using real Claude Code tools (Read, Edit, Bash, Task).

Usage in Claude Code:
    1. Select a complex function in editor
    2. Run: /refactor-function
    3. Review proposed changes
    4. Approve to apply

Command-line usage for testing:
    .claude/commands/refactor-function-prod --file path/to/file.py --function func_name
    .claude/commands/refactor-function-prod --dry-run
"""

import sys
import os
import json
import re
from pathlib import Path
from typing import Optional, Dict, List, Tuple

# NOTE: In real Claude Code environment, tools are available via MCP
# For standalone testing, we simulate the tool calls
CLAUDE_CODE_MODE = os.environ.get('CLAUDE_CODE_MODE', 'false') == 'true'

class RefactorCommand:
    """Production: Automated function refactoring using real tools."""

    def __init__(self, target_complexity: int = 6, dry_run: bool = False):
        self.target_complexity = target_complexity
        self.dry_run = dry_run
        self.project_root = Path(__file__).parent.parent.parent

    def extract_function_from_file(self, file_path: str, function_name: str) -> Optional[Dict]:
        """Extract function code using Read tool."""
        print(f"üìñ Reading {file_path}...")

        # Real implementation: Use Read tool
        try:
            with open(self.project_root / file_path, 'r') as f:
                content = f.read()

            # Find function definition
            pattern = rf'^\s*def {re.escape(function_name)}\s*\('
            lines = content.split('\n')

            start_line = None
            for i, line in enumerate(lines, 1):
                if re.match(pattern, line):
                    start_line = i
                    break

            if not start_line:
                print(f"  ‚ùå Function '{function_name}' not found")
                return None

            # Find end of function (next def or class at same indent level)
            start_indent = len(lines[start_line - 1]) - len(lines[start_line - 1].lstrip())
            end_line = len(lines)

            for i in range(start_line, len(lines)):
                line = lines[i]
                if line.strip() and not line.strip().startswith('#'):
                    curr_indent = len(line) - len(line.lstrip())
                    if curr_indent <= start_indent and (line.strip().startswith('def ') or line.strip().startswith('class ')):
                        end_line = i
                        break

            function_code = '\n'.join(lines[start_line-1:end_line])

            print(f"  ‚úì Found {function_name} at lines {start_line}-{end_line}")

            return {
                "file": file_path,
                "function": function_name,
                "line_start": start_line,
                "line_end": end_line,
                "code": function_code,
                "full_content": content
            }

        except Exception as e:
            print(f"  ‚ùå Error reading file: {e}")
            return None

    def call_agent(self, agent_type: str, prompt: str) -> str:
        """Call Claude Code agent via Task tool (or simulate for testing)."""
        if CLAUDE_CODE_MODE:
            # Real Claude Code: Use Task tool
            # This would be a system call or MCP protocol call
            # For now, we print what would be called
            print(f"  [AGENT CALL: {agent_type}]")
            print(f"  Prompt: {prompt[:100]}...")

        # For testing/standalone: Return mock response
        # In production, parse actual agent response
        return ""

    def run_baseline_analysis(self, context: Dict) -> Dict:
        """Run code-quality-guard for baseline metrics."""
        print(f"\nüìä Analyzing baseline complexity for {context['function']}...")

        prompt = f"""Analyze complexity for function '{context['function']}' in {context['file']}.

Function code:
```python
{context['code']}
```

Return ONLY a JSON object with these exact keys:
{{
    "function": "{context['function']}",
    "complexity": <number>,
    "nesting": <number>,
    "grade": "<letter>",
    "issues": ["<issue1>", "<issue2>", ...]
}}
"""

        # In production: Parse agent response
        # For now: Analyze using simple heuristics
        code = context['code']

        # Count complexity indicators
        complexity = sum([
            code.count('if '),
            code.count('elif '),
            code.count('for '),
            code.count('while '),
            code.count('except '),
            code.count('and '),
            code.count('or '),
        ])

        # Estimate nesting (count max indent depth)
        lines = code.split('\n')
        max_indent = 0
        for line in lines:
            if line.strip():
                indent = (len(line) - len(line.lstrip())) // 4
                max_indent = max(max_indent, indent)

        # Grade based on complexity
        if complexity <= 5:
            grade = 'A'
        elif complexity <= 10:
            grade = 'B'
        elif complexity <= 15:
            grade = 'C'
        else:
            grade = 'D'

        baseline = {
            "function": context['function'],
            "complexity": complexity,
            "nesting": max_indent,
            "grade": grade,
            "issues": []
        }

        if complexity > 10:
            baseline['issues'].append(f"High complexity ({complexity})")
        if max_indent > 3:
            baseline['issues'].append(f"Deep nesting ({max_indent} levels)")
        if 'for ' in code and 'if ' in code:
            baseline['issues'].append("Nested loops and conditions")

        print(f"  Complexity: {baseline['complexity']} ({baseline['grade']}-grade)")
        print(f"  Nesting: {baseline['nesting']} levels")
        if baseline['issues']:
            print(f"  Issues: {len(baseline['issues'])}")
            for issue in baseline['issues']:
                print(f"    - {issue}")

        return baseline

    def run_refactoring(self, context: Dict, baseline: Dict) -> Optional[Dict]:
        """Run amp-bridge for refactoring."""
        print(f"\nüîß Refactoring {context['function']}...")
        print(f"  Target: Complexity ‚â§{self.target_complexity}, Nesting ‚â§3")

        prompt = f"""Refactor function '{context['function']}' in {context['file']}.

Current code:
```python
{context['code']}
```

Current metrics:
- Complexity: {baseline['complexity']}
- Nesting: {baseline['nesting']} levels
- Grade: {baseline['grade']}

Target:
- Complexity: ‚â§{self.target_complexity}
- Nesting: ‚â§3 levels

Apply Extract Method pattern. Return ONLY JSON with structure:
{{
    "refactored_code": "def {context['function']}...",
    "helpers": [
        {{"name": "_helper_name", "code": "def _helper_name..."}},
        ...
    ],
    "complexity": <number>,
    "nesting": <number>
}}
"""

        # In production: Get real refactored code from amp-bridge
        # For MVP: Return structure indicating what would happen
        # Real implementation would parse agent's JSON response

        result = {
            "refactored_code": context['code'],  # Would be actual refactored code
            "helpers": [],
            "complexity": baseline['complexity'],  # Would be measured after refactoring
            "nesting": baseline['nesting'],
            "applied": False
        }

        print(f"  ‚ö†Ô∏è  Production mode not fully implemented yet")
        print(f"  ‚ö†Ô∏è  Would call amp-bridge agent here")
        print(f"  ‚ö†Ô∏è  For full implementation, set CLAUDE_CODE_MODE=true")

        return result

    def validate_refactoring(self, refactored: Dict) -> bool:
        """Validate refactoring met targets."""
        print(f"\n‚úÖ Validating refactoring...")

        complexity = refactored.get('complexity', 999)
        nesting = refactored.get('nesting', 999)

        complexity_ok = complexity <= self.target_complexity
        nesting_ok = nesting <= 3

        print(f"  Complexity: {complexity} (target: ‚â§{self.target_complexity}) {'‚úì' if complexity_ok else '‚úó'}")
        print(f"  Nesting: {nesting} levels (target: ‚â§3) {'‚úì' if nesting_ok else '‚úó'}")
        print(f"  Helpers: {len(refactored.get('helpers', []))}")

        return complexity_ok and nesting_ok

    def show_diff_and_confirm(self, context: Dict, baseline: Dict, refactored: Dict) -> bool:
        """Show diff and get user confirmation."""
        print(f"\n{'='*60}")
        print("REFACTORING SUMMARY")
        print(f"{'='*60}")

        print(f"\nüìÅ File: {context['file']}")
        print(f"üìç Function: {context['function']} (lines {context['line_start']}-{context['line_end']})")

        print(f"\nüìä Before:")
        print(f"  Complexity: {baseline['complexity']} ({baseline['grade']}-grade)")
        print(f"  Nesting: {baseline['nesting']} levels")

        print(f"\nüìä After:")
        print(f"  Complexity: {refactored['complexity']}")
        print(f"  Nesting: {refactored['nesting']} levels")

        if refactored.get('helpers'):
            print(f"\nüîß Extracted Helpers:")
            for helper in refactored['helpers']:
                print(f"  - {helper['name']}")

        if baseline['complexity'] > refactored['complexity']:
            improvement = ((baseline['complexity'] - refactored['complexity']) / baseline['complexity']) * 100
            print(f"\nüìà Improvement: -{improvement:.1f}% complexity")

        if self.dry_run:
            print(f"\n{'='*60}")
            print("[DRY RUN] No changes applied")
            print(f"{'='*60}")
            return False

        print(f"\n{'='*60}")
        try:
            response = input("Apply changes? [y/n]: ").strip().lower()
            return response == 'y'
        except (EOFError, KeyboardInterrupt):
            print("\n‚ùå Cancelled")
            return False

    def apply_changes(self, context: Dict, refactored: Dict) -> bool:
        """Apply refactored code using Edit tool."""
        print(f"\nüìù Applying changes to {context['file']}...")

        if not refactored.get('applied', False):
            # Would use Edit tool here in production
            print(f"  ‚ö†Ô∏è  Edit tool integration not implemented in MVP")
            print(f"  ‚ö†Ô∏è  In production, would replace lines {context['line_start']}-{context['line_end']}")
            return False

        print(f"  ‚úì Updated {context['function']}")
        for helper in refactored.get('helpers', []):
            print(f"  ‚úì Added {helper['name']}")

        return True

    def create_commit(self, context: Dict, baseline: Dict, refactored: Dict) -> bool:
        """Create git commit using Bash tool."""
        print(f"\nüíæ Create commit?")

        complexity_reduction = baseline['complexity'] - refactored['complexity']
        pct_reduction = (complexity_reduction / baseline['complexity']) * 100

        message = f"""refactor: Reduce complexity in {context['function']}

- Complexity: {baseline['complexity']}‚Üí{refactored['complexity']} (-{pct_reduction:.0f}%)
- Nesting: {baseline['nesting']}‚Üí{refactored['nesting']} levels
- Extracted {len(refactored.get('helpers', []))} helpers

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"""

        print(f"\nProposed commit message:")
        print("-" * 60)
        print(message)
        print("-" * 60)

        try:
            response = input("\nCreate commit? [y/n]: ").strip().lower()
            if response == 'y':
                # Would use Bash tool here in production
                print(f"  ‚ö†Ô∏è  Git integration not implemented in MVP")
                return False
        except (EOFError, KeyboardInterrupt):
            print("\n‚ùå Cancelled")
            return False

        return False

    def run(self, file_path: Optional[str] = None, function_name: Optional[str] = None):
        """Execute the refactoring workflow."""
        print("üîÑ /refactor-function - Automated Complexity Reduction\n")

        # 1. Get function context
        if not file_path or not function_name:
            print("‚ùå Usage: --file <path> --function <name>")
            return 1

        context = self.extract_function_from_file(file_path, function_name)
        if not context:
            return 1

        # 2. Baseline analysis
        baseline = self.run_baseline_analysis(context)

        if baseline['complexity'] <= self.target_complexity:
            print(f"\n‚úì Function already meets target (C={baseline['complexity']})")
            return 0

        # 3. Refactoring
        refactored = self.run_refactoring(context, baseline)
        if not refactored:
            print("\n‚ùå Refactoring failed")
            return 1

        # 4. Validation
        if not self.validate_refactoring(refactored):
            print("\n‚ö†Ô∏è  Refactoring didn't meet all targets")
            if not self.dry_run:
                response = input("Continue anyway? [y/n]: ").strip().lower()
                if response != 'y':
                    return 1

        # 5. User confirmation
        if not self.show_diff_and_confirm(context, baseline, refactored):
            print("\n‚ùå Changes not applied")
            return 0

        # 6. Apply changes
        if not self.apply_changes(context, refactored):
            print("\n‚ö†Ô∏è  Changes not applied (MVP limitation)")
            if not self.dry_run:
                print("\nTo complete this refactoring:")
                print("1. Use amp-bridge agent directly")
                print("2. Or refactor manually using the metrics above")
            return 0

        # 7. Optional commit
        self.create_commit(context, baseline, refactored)

        print("\n‚úÖ Refactoring complete!")
        return 0

def main():
    """CLI entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="/refactor-function - Automated function complexity reduction",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Analyze and refactor a function
  %(prog)s --file claude-hooks/install_hooks.py --function detect_claude_mcp_configuration

  # Dry run (show plan without applying)
  %(prog)s --file path/to/file.py --function my_function --dry-run

  # Custom complexity target
  %(prog)s --file path/to/file.py --function my_function --target-complexity 5
        """
    )

    parser.add_argument(
        '--file',
        type=str,
        help='Path to file containing function'
    )
    parser.add_argument(
        '--function',
        type=str,
        help='Name of function to refactor'
    )
    parser.add_argument(
        '--target-complexity',
        type=int,
        default=6,
        help='Target cyclomatic complexity (default: 6)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Show plan without applying changes'
    )

    args = parser.parse_args()

    command = RefactorCommand(
        target_complexity=args.target_complexity,
        dry_run=args.dry_run
    )

    sys.exit(command.run(
        file_path=args.file,
        function_name=args.function
    ))

if __name__ == '__main__':
    main()
